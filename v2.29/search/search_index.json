{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mockery \u00b6 Mockery is a project that creates mock implementations of Golang interfaces. The mocks generated in this project are based off of the github.com/stretchr/testify suite of testing packages. Why mockery? \u00b6 When you have an interface like this: db.go type DB interface { Get ( val string ) string } and a function that takes this interface: db_getter.go func getFromDB ( db DB ) string { return db . Get ( \"ice cream\" ) } You can test getFromDB by either instantiating a testing database, or you can simply create a mock implementation of DB using mockery. Mockery can autogenerate a mock implementation that allows us to define assertions on how the mock was used, what to return, and other useful tidbits. We can add a //go:generate directive above our interface: db.go //go:generate mockery --name DB type DB interface { Get ( val string ) string } .mockery.yaml inpackage : True # (1)! with-expecter : True # (2)! testonly : True # (3)! Generate our mocks next to the original interface Create expecter methods Append _test.go to the filename so the mock object is not packaged Bash $ go generate 05 Mar 23 21 :49 CST INF Starting mockery dry-run = false version = v2.20.0 05 Mar 23 21 :49 CST INF Using config: .mockery.yaml dry-run = false version = v2.20.0 05 Mar 23 21 :49 CST INF Walking dry-run = false version = v2.20.0 05 Mar 23 21 :49 CST INF Generating mock dry-run = false interface = DB qualified-name = github.com/vektra/mockery/v2/pkg/fixtures/example_project version = v2.20.0 We can then use the mock object in a test: db_getter_test.go import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_getFromDB ( t * testing . T ) { mockDB := NewMockDB ( t ) mockDB . EXPECT (). Get ( \"ice cream\" ). Return ( \"chocolate\" ). Once () flavor := getFromDB ( mockDB ) assert . Equal ( t , \"chocolate\" , flavor ) } Why use mockery over gomock? \u00b6 mockery provides a much more user-friendly API and is less confusing to use mockery utilizes testify which is a robust and highly feature-rich testing framework mockery has rich configuration options that allow fine-grained control over how your mocks are generated mockery's CLI is more robust, user-friendly, and provides many more options mockery supports generics (this may no longer be an advantage if/when gomock supports generics) Who uses mockery? \u00b6 :simple-grafana: grafana \u00b7 :simple-google: Google Skia \u00b7 Hashicorp \u00b7 :simple-google: Google Skyzkaller \u00b7 Uber Cadence \u00b7 Jaeger \u00b7 Splunk \u00b7 Ignite CLI \u00b7 Tendermint \u00b7 Datadog Get Started","title":"Home"},{"location":"#mockery","text":"Mockery is a project that creates mock implementations of Golang interfaces. The mocks generated in this project are based off of the github.com/stretchr/testify suite of testing packages.","title":"mockery"},{"location":"#why-mockery","text":"When you have an interface like this: db.go type DB interface { Get ( val string ) string } and a function that takes this interface: db_getter.go func getFromDB ( db DB ) string { return db . Get ( \"ice cream\" ) } You can test getFromDB by either instantiating a testing database, or you can simply create a mock implementation of DB using mockery. Mockery can autogenerate a mock implementation that allows us to define assertions on how the mock was used, what to return, and other useful tidbits. We can add a //go:generate directive above our interface: db.go //go:generate mockery --name DB type DB interface { Get ( val string ) string } .mockery.yaml inpackage : True # (1)! with-expecter : True # (2)! testonly : True # (3)! Generate our mocks next to the original interface Create expecter methods Append _test.go to the filename so the mock object is not packaged Bash $ go generate 05 Mar 23 21 :49 CST INF Starting mockery dry-run = false version = v2.20.0 05 Mar 23 21 :49 CST INF Using config: .mockery.yaml dry-run = false version = v2.20.0 05 Mar 23 21 :49 CST INF Walking dry-run = false version = v2.20.0 05 Mar 23 21 :49 CST INF Generating mock dry-run = false interface = DB qualified-name = github.com/vektra/mockery/v2/pkg/fixtures/example_project version = v2.20.0 We can then use the mock object in a test: db_getter_test.go import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Test_getFromDB ( t * testing . T ) { mockDB := NewMockDB ( t ) mockDB . EXPECT (). Get ( \"ice cream\" ). Return ( \"chocolate\" ). Once () flavor := getFromDB ( mockDB ) assert . Equal ( t , \"chocolate\" , flavor ) }","title":"Why mockery?"},{"location":"#why-use-mockery-over-gomock","text":"mockery provides a much more user-friendly API and is less confusing to use mockery utilizes testify which is a robust and highly feature-rich testing framework mockery has rich configuration options that allow fine-grained control over how your mocks are generated mockery's CLI is more robust, user-friendly, and provides many more options mockery supports generics (this may no longer be an advantage if/when gomock supports generics)","title":"Why use mockery over gomock?"},{"location":"#who-uses-mockery","text":":simple-grafana: grafana \u00b7 :simple-google: Google Skia \u00b7 Hashicorp \u00b7 :simple-google: Google Skyzkaller \u00b7 Uber Cadence \u00b7 Jaeger \u00b7 Splunk \u00b7 Ignite CLI \u00b7 Tendermint \u00b7 Datadog Get Started","title":"Who uses mockery?"},{"location":"changelog/","text":"Changelog \u00b6 This changelog describes major feature additions. Please view the releases page for more details on commits and minor changes. v2.25.0 recursive config \u00b6 The recursive parameter allows mockery to dynamically discover sub-packages when using the packages config. v2.24.0 exclude config \u00b6 The exclude parameter allows you to define subpaths to ignore. This is currently only compatible when using non- packages config. v2.23.0 Replace Types \u00b6 The replace-type parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages. v2.21.0 : packages configuration \u00b6 In this version we release the packages configuration section. This new parameter allows defining specific packages to generate mocks for, while also giving fine-grained control over which interfaces are mocked, where they are located, and how they are configured. Details are provided here . Community input is desired before we consider deprecations of dynamic walking (via all : True ): https://github.com/vektra/mockery/discussions/549 v2.20.0 : Improved Return Value Functions \u00b6 Return value functions that return an entire method's return value signature can now be provided. Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) ( string , error ) { return s , nil } ) You may still use the old way where one function is provided for each return value: Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) string { return s }, func ( ctx context . Context , s string ) error { return nil }, ) 2.19.0 : inpackage-suffix option \u00b6 When inpackage-suffix is set to True , mock files are suffixed with _mock instead of being prefixed with mock_ for InPackage mocks v2.16.0 : Config Search Path \u00b6 Mockery will iteratively search every directory from the current working directory up to the root path for a .mockery.yaml file, if one is not explicitly provided. v2.13.0 : Generics support \u00b6 Mocks are now capable of supporting Golang generics. v2.11.0 : Mock constructors \u00b6 Mockery v2.11 introduces constructors for all mocks. This makes instantiation and mock registration a bit easier and less error-prone (you won't have to worry about forgetting the AssertExpectations method call anymore). Before v2.11: Go factory := & mocks . Factory {} factory . Test ( t ) // so that mock does not panic when a method is unexpected defer factory . AssertExpectations ( t ) After v2.11: Go factory := mocks . NewFactory ( t ) The constructor sets up common functionalities automatically - The AssertExpectations method is registered to be called at the end of the tests via t.Cleanup() method. - The testing.TB interface is registered on the mock.Mock so that tests don't panic when a call on the mock is unexpected. v2.10.0 : Expecter Structs \u00b6 Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the with-expecter: True mockery configuration, you can enter into the expecter interface by simply calling .EXPECT() on your mock object. For example, given an interface such as Go type Requester interface { Get ( path string ) ( string , error ) } You can use the type-safe expecter interface as such: Go requesterMock := mocks . NewRequester ( t ) requesterMock . EXPECT (). Get ( \"some path\" ). Return ( \"result\" , nil ) requesterMock . EXPECT (). Get ( mock . Anything ). Run ( func ( path string ) { fmt . Println ( path , \"was called\" ) }). // Can still use return functions by getting the embedded mock.Call Call . Return ( func ( path string ) string { return \"result for \" + path }, nil ) v2.0.0 : Major Update \u00b6 This is the first major update of mockery. Version 2 brings a handful of improvements to mockery: Structured and pretty console logging CLI now switches over to sp13/cobra Use of viper configuration parsing. You can now use a .mockery.yaml config file in your repository Various CI fixes and improvements","title":"Changelog"},{"location":"changelog/#changelog","text":"This changelog describes major feature additions. Please view the releases page for more details on commits and minor changes.","title":"Changelog"},{"location":"changelog/#v2250-recursive-config","text":"The recursive parameter allows mockery to dynamically discover sub-packages when using the packages config.","title":" v2.25.0 recursive config"},{"location":"changelog/#v2240-exclude-config","text":"The exclude parameter allows you to define subpaths to ignore. This is currently only compatible when using non- packages config.","title":" v2.24.0 exclude config"},{"location":"changelog/#v2230-replace-types","text":"The replace-type parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.","title":" v2.23.0 Replace Types"},{"location":"changelog/#v2210-packages-configuration","text":"In this version we release the packages configuration section. This new parameter allows defining specific packages to generate mocks for, while also giving fine-grained control over which interfaces are mocked, where they are located, and how they are configured. Details are provided here . Community input is desired before we consider deprecations of dynamic walking (via all : True ): https://github.com/vektra/mockery/discussions/549","title":" v2.21.0: packages configuration"},{"location":"changelog/#v2200-improved-return-value-functions","text":"Return value functions that return an entire method's return value signature can now be provided. Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) ( string , error ) { return s , nil } ) You may still use the old way where one function is provided for each return value: Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) string { return s }, func ( ctx context . Context , s string ) error { return nil }, )","title":" v2.20.0: Improved Return Value Functions"},{"location":"changelog/#2190-inpackage-suffix-option","text":"When inpackage-suffix is set to True , mock files are suffixed with _mock instead of being prefixed with mock_ for InPackage mocks","title":" 2.19.0: inpackage-suffix option"},{"location":"changelog/#v2160-config-search-path","text":"Mockery will iteratively search every directory from the current working directory up to the root path for a .mockery.yaml file, if one is not explicitly provided.","title":" v2.16.0: Config Search Path"},{"location":"changelog/#v2130-generics-support","text":"Mocks are now capable of supporting Golang generics.","title":" v2.13.0: Generics support"},{"location":"changelog/#v2110-mock-constructors","text":"Mockery v2.11 introduces constructors for all mocks. This makes instantiation and mock registration a bit easier and less error-prone (you won't have to worry about forgetting the AssertExpectations method call anymore). Before v2.11: Go factory := & mocks . Factory {} factory . Test ( t ) // so that mock does not panic when a method is unexpected defer factory . AssertExpectations ( t ) After v2.11: Go factory := mocks . NewFactory ( t ) The constructor sets up common functionalities automatically - The AssertExpectations method is registered to be called at the end of the tests via t.Cleanup() method. - The testing.TB interface is registered on the mock.Mock so that tests don't panic when a call on the mock is unexpected.","title":" v2.11.0: Mock constructors"},{"location":"changelog/#v2100-expecter-structs","text":"Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the with-expecter: True mockery configuration, you can enter into the expecter interface by simply calling .EXPECT() on your mock object. For example, given an interface such as Go type Requester interface { Get ( path string ) ( string , error ) } You can use the type-safe expecter interface as such: Go requesterMock := mocks . NewRequester ( t ) requesterMock . EXPECT (). Get ( \"some path\" ). Return ( \"result\" , nil ) requesterMock . EXPECT (). Get ( mock . Anything ). Run ( func ( path string ) { fmt . Println ( path , \"was called\" ) }). // Can still use return functions by getting the embedded mock.Call Call . Return ( func ( path string ) string { return \"result for \" + path }, nil )","title":" v2.10.0: Expecter Structs"},{"location":"changelog/#v200-major-update","text":"This is the first major update of mockery. Version 2 brings a handful of improvements to mockery: Structured and pretty console logging CLI now switches over to sp13/cobra Use of viper configuration parsing. You can now use a .mockery.yaml config file in your repository Various CI fixes and improvements","title":" v2.0.0: Major Update"},{"location":"configuration/","text":"Configuration \u00b6 mockery uses spf13/viper under the hood for its configuration parsing. It is bound to three different configuration sources, in order of decreasing precedence: Command line Environment variables Configuration file If a parameter is named with-expecter and we want a value of True , then these are the formats for each source: source value command line --with-expecter=true Environment variable MOCKERY_WITH_EXPECTER=True yaml with-expecter: True Recommended Basic Config \u00b6 Copy the recommended basic configuration to a file called .mockery.yaml at the top-level of your repo: .mockery.yaml inpackage : True testonly : True with-expecter : True keeptree : False mockery will search upwards from your current-working-directory up to the root path, so the same configuration should be able to follow you within your project. Parameter Descriptions \u00b6 non- packages \u00b6 These are the configuration options available when using the legacy, non- packages configuration semantics. non- packages config name description all It's common for a big package to have a lot of interfaces, so mockery provides all . This option will tell mockery to scan all files under the directory named by --dir (\".\" by default) and generates mocks for any interfaces it finds. This option implies recursive: True . boilerplate-file Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. case mockery generates files using the casing of the original interface name. This can be modified by specifying case: underscore to format the generated file name using underscore casing. exclude This parameter is a list of strings representing path prefixes that should be excluded from mock generation. exported Use exported: True to generate public mocks for private interfaces. filename Use the filename and structname to override the default generated file and struct name. These options are only compatible with non-regular expressions in name , where only one mock is generated. inpackage-suffix When inpackage-suffix is set to True , mock files are suffixed with _mock instead of being prefixed with mock_ for InPackage mocks inpackage and keeptree For some complex repositories, there could be multiple interfaces with the same name but in different packages. In that case, inpackage allows generating the mocked interfaces directly in the package that it mocks. In the case you don't want to generate the mocks into the package but want to keep a similar structure, use the option keeptree . name The name option takes either the name or matching regular expression of the interface to generate mock(s) for. output mockery always generates files with the package mocks to keep things clean and simple. You can control which mocks directory is used by using output , which defaults to ./mocks . outpkg Use outpkg to specify the package name of the generated mocks. print Use print: True to have the resulting code printed out instead of written to disk. recursive Use the recursive option to search subdirectories for the interface(s). This option is only compatible with name . The all option implies recursive: True . replace-type source=destination Replaces aliases, packages and/or types during generation. testonly Prepend every mock file with _test.go . This is useful in cases where you are generating mocks inpackage but don't want the mocks to be visible to code outside of tests. with-expecter Use with-expecter: True to generate EXPECT() methods for your mocks. This is the preferred way to setup your mocks. packages config \u00b6 These are the config options when using the packages config option. Use of the packages config semantics puts mockery into a completely different code path. Config variables may have changed meanings or have been substracted entirely, compared to the non- packages config. Please see the features section for more details on how packages works, including some example configuration. packages config name templated default description all false Generate all interfaces for the specified packages. boilerplate-file \"\" Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. config \"\" Set the location of the mockery config file. dir \"mocks/{{.PackagePath}}\" The directory where the mock file will be outputted to. disable-config-search false Disable searching for configuration files disable-version-string false Disable the version string in the generated mock files. dry-run false Print the actions that would be taken, but don't perform the actions. filename \"mock_{{.InterfaceName}}.go\" The name of the file the mock will reside in. inpackage false When generating mocks alongside the original interfaces, you must specify inpackage: True to inform mockery that the mock is being placed in the same package as the original interface. mockname \"Mock{{.InterfaceName}}\" The name of the generated mock. outpkg \"{{.PackageName}}\" Use outpkg to specify the package name of the generated mocks. log-level \"info\" Set the level of the logger packages null A dictionary containing configuration describing the packages and interfaces to generate mocks for. print false Use print: True to have the resulting code printed out instead of written to disk. recursive false When set to true on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. tags \"\" Set the build tags of the generated mocks. with-expecter true Use with-expecter: True to generate EXPECT() methods for your mocks. This is the preferred way to setup your mocks. replace-type null Replaces aliases, packages and/or types during generation. Template Variables \u00b6 Note Templated variables are only available when using the packages config feature. Variables that are marked as being templated are capable of using mockery-provided template parameters. name description InterfaceDir The directory path of the original interface being mocked. This can be used as dir : \"{{.InterfaceDir}}\" to place your mocks adjacent to the original interface. This should not be used for external interfaces. InterfaceDirRelative The directory path of the original interface being mocked, relative to the current working directory. If the path cannot be made relative to the current working directory, this variable will be set equal to PackagePath InterfaceName The name of the original interface being mocked InterfaceNameCamel Converts a string interface_name to InterfaceName InterfaceNameLowerCamel Converts InterfaceName to interfaceName InterfaceNameSnake Converts InterfaceName to interface_name Mock A string that is Mock if the interface is exported, or mock if it is not exported. Useful when setting the name of your mock to something like: mockname : \"{{.Mock}}{{.InterfaceName}}\" This way, the mock name will retain the exported-ness of the original interface. MockName The name of the mock that will be generated. Note that this is simply the mockname configuration variable PackageName The name of the package from the original interface PackagePath The fully qualified package path of the original interface Template functions \u00b6 Note Templated functions are only available when using the packages config feature. Template functions allow you to inspect and manipulate template variables. All template functions are calling native Go functions under the hood, so signatures and return values matches the Go functions you are probably already familiar with. To learn more about the templating syntax, please see the Go text/template documentation contains string substr hasPrefix string prefix hasSuffix string suffix join elems sep replace string old new n replaceAll string old new split string sep splitAfter string sep splitAfterN string sep n trim string cutset trimLeft string cutset trimPrefix string prefix trimRight string cutset trimSpace string trimSuffix string suffix matchString pattern quoteMeta string base string clean string dir string expandEnv string getenv string","title":"Configuration"},{"location":"configuration/#configuration","text":"mockery uses spf13/viper under the hood for its configuration parsing. It is bound to three different configuration sources, in order of decreasing precedence: Command line Environment variables Configuration file If a parameter is named with-expecter and we want a value of True , then these are the formats for each source: source value command line --with-expecter=true Environment variable MOCKERY_WITH_EXPECTER=True yaml with-expecter: True","title":"Configuration"},{"location":"configuration/#recommended-basic-config","text":"Copy the recommended basic configuration to a file called .mockery.yaml at the top-level of your repo: .mockery.yaml inpackage : True testonly : True with-expecter : True keeptree : False mockery will search upwards from your current-working-directory up to the root path, so the same configuration should be able to follow you within your project.","title":"Recommended Basic Config"},{"location":"configuration/#parameter-descriptions","text":"","title":"Parameter Descriptions"},{"location":"configuration/#non-packages","text":"These are the configuration options available when using the legacy, non- packages configuration semantics. non- packages config name description all It's common for a big package to have a lot of interfaces, so mockery provides all . This option will tell mockery to scan all files under the directory named by --dir (\".\" by default) and generates mocks for any interfaces it finds. This option implies recursive: True . boilerplate-file Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. case mockery generates files using the casing of the original interface name. This can be modified by specifying case: underscore to format the generated file name using underscore casing. exclude This parameter is a list of strings representing path prefixes that should be excluded from mock generation. exported Use exported: True to generate public mocks for private interfaces. filename Use the filename and structname to override the default generated file and struct name. These options are only compatible with non-regular expressions in name , where only one mock is generated. inpackage-suffix When inpackage-suffix is set to True , mock files are suffixed with _mock instead of being prefixed with mock_ for InPackage mocks inpackage and keeptree For some complex repositories, there could be multiple interfaces with the same name but in different packages. In that case, inpackage allows generating the mocked interfaces directly in the package that it mocks. In the case you don't want to generate the mocks into the package but want to keep a similar structure, use the option keeptree . name The name option takes either the name or matching regular expression of the interface to generate mock(s) for. output mockery always generates files with the package mocks to keep things clean and simple. You can control which mocks directory is used by using output , which defaults to ./mocks . outpkg Use outpkg to specify the package name of the generated mocks. print Use print: True to have the resulting code printed out instead of written to disk. recursive Use the recursive option to search subdirectories for the interface(s). This option is only compatible with name . The all option implies recursive: True . replace-type source=destination Replaces aliases, packages and/or types during generation. testonly Prepend every mock file with _test.go . This is useful in cases where you are generating mocks inpackage but don't want the mocks to be visible to code outside of tests. with-expecter Use with-expecter: True to generate EXPECT() methods for your mocks. This is the preferred way to setup your mocks.","title":"non-packages"},{"location":"configuration/#packages-config","text":"These are the config options when using the packages config option. Use of the packages config semantics puts mockery into a completely different code path. Config variables may have changed meanings or have been substracted entirely, compared to the non- packages config. Please see the features section for more details on how packages works, including some example configuration. packages config name templated default description all false Generate all interfaces for the specified packages. boilerplate-file \"\" Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. config \"\" Set the location of the mockery config file. dir \"mocks/{{.PackagePath}}\" The directory where the mock file will be outputted to. disable-config-search false Disable searching for configuration files disable-version-string false Disable the version string in the generated mock files. dry-run false Print the actions that would be taken, but don't perform the actions. filename \"mock_{{.InterfaceName}}.go\" The name of the file the mock will reside in. inpackage false When generating mocks alongside the original interfaces, you must specify inpackage: True to inform mockery that the mock is being placed in the same package as the original interface. mockname \"Mock{{.InterfaceName}}\" The name of the generated mock. outpkg \"{{.PackageName}}\" Use outpkg to specify the package name of the generated mocks. log-level \"info\" Set the level of the logger packages null A dictionary containing configuration describing the packages and interfaces to generate mocks for. print false Use print: True to have the resulting code printed out instead of written to disk. recursive false When set to true on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. tags \"\" Set the build tags of the generated mocks. with-expecter true Use with-expecter: True to generate EXPECT() methods for your mocks. This is the preferred way to setup your mocks. replace-type null Replaces aliases, packages and/or types during generation.","title":"packages config"},{"location":"configuration/#template-variables","text":"Note Templated variables are only available when using the packages config feature. Variables that are marked as being templated are capable of using mockery-provided template parameters. name description InterfaceDir The directory path of the original interface being mocked. This can be used as dir : \"{{.InterfaceDir}}\" to place your mocks adjacent to the original interface. This should not be used for external interfaces. InterfaceDirRelative The directory path of the original interface being mocked, relative to the current working directory. If the path cannot be made relative to the current working directory, this variable will be set equal to PackagePath InterfaceName The name of the original interface being mocked InterfaceNameCamel Converts a string interface_name to InterfaceName InterfaceNameLowerCamel Converts InterfaceName to interfaceName InterfaceNameSnake Converts InterfaceName to interface_name Mock A string that is Mock if the interface is exported, or mock if it is not exported. Useful when setting the name of your mock to something like: mockname : \"{{.Mock}}{{.InterfaceName}}\" This way, the mock name will retain the exported-ness of the original interface. MockName The name of the mock that will be generated. Note that this is simply the mockname configuration variable PackageName The name of the package from the original interface PackagePath The fully qualified package path of the original interface","title":"Template Variables"},{"location":"configuration/#template-functions","text":"Note Templated functions are only available when using the packages config feature. Template functions allow you to inspect and manipulate template variables. All template functions are calling native Go functions under the hood, so signatures and return values matches the Go functions you are probably already familiar with. To learn more about the templating syntax, please see the Go text/template documentation contains string substr hasPrefix string prefix hasSuffix string suffix join elems sep replace string old new n replaceAll string old new split string sep splitAfter string sep splitAfterN string sep n trim string cutset trimLeft string cutset trimPrefix string prefix trimRight string cutset trimSpace string trimSuffix string suffix matchString pattern quoteMeta string base string clean string dir string expandEnv string getenv string","title":"Template functions"},{"location":"examples/","text":"Examples \u00b6 Simple case \u00b6 Given this interface: string.go package example_project //go:generate mockery --name Stringer type Stringer interface { String () string } Run: go generate (using the recommended config) and the the file mock_Stringer_test.go will be generated. You can now use this mock to create assertions and expectations. string_test.go package example_project import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Foo ( s Stringer ) string { return s . String () } func TestString ( t * testing . T ) { mockStringer := NewMockStringer ( t ) mockStringer . EXPECT (). String (). Return ( \"mockery\" ) assert . Equal ( t , \"mockery\" , Foo ( mockStringer )) } Note that in combination with using the mock's constructor and the .EXPECT() directives, your test will automatically fail if the expected call is not made. Function type case \u00b6 Given this is in send.go Go package test type SendFunc func ( data string ) ( int , error ) Run: mockery --name=SendFunc and the following will be output: mock_SendFunc_test.go package mocks import ( \"github.com/stretchr/testify/mock\" testing \"testing\" ) type SendFunc struct { mock . Mock } func ( _m * SendFunc ) Execute ( data string ) ( int , error ) { ret := _m . Called ( data ) var r0 int if rf , ok := ret . Get ( 0 ).( func ( string ) int ); ok { r0 = rf ( data ) } else { r0 = ret . Get ( 0 ).( int ) } var r1 error if rf , ok := ret . Get ( 1 ).( func ( string ) error ); ok { r1 = rf ( data ) } else { r1 = ret . Error ( 1 ) } return r0 , r1 } // NewSendFunc creates a new instance of SendFunc. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations. func NewSendFunc ( t testing . TB ) * SendFunc { mock := & SendFunc {} mock . Mock . Test ( t ) t . Cleanup ( func () { mock . AssertExpectations ( t ) }) return mock } Return Value Provider Functions \u00b6 If your tests need access to the arguments to calculate the return values, set the return value to a function that takes the method's arguments as its own arguments and returns the return value. For example, given this interface: Go package test type Proxy interface { passthrough ( ctx context . Context , s string ) string } The argument can be passed through as the return value: Go import . \"github.com/stretchr/testify/mock\" proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) string { return s })","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#simple-case","text":"Given this interface: string.go package example_project //go:generate mockery --name Stringer type Stringer interface { String () string } Run: go generate (using the recommended config) and the the file mock_Stringer_test.go will be generated. You can now use this mock to create assertions and expectations. string_test.go package example_project import ( \"testing\" \"github.com/stretchr/testify/assert\" ) func Foo ( s Stringer ) string { return s . String () } func TestString ( t * testing . T ) { mockStringer := NewMockStringer ( t ) mockStringer . EXPECT (). String (). Return ( \"mockery\" ) assert . Equal ( t , \"mockery\" , Foo ( mockStringer )) } Note that in combination with using the mock's constructor and the .EXPECT() directives, your test will automatically fail if the expected call is not made.","title":"Simple case"},{"location":"examples/#function-type-case","text":"Given this is in send.go Go package test type SendFunc func ( data string ) ( int , error ) Run: mockery --name=SendFunc and the following will be output: mock_SendFunc_test.go package mocks import ( \"github.com/stretchr/testify/mock\" testing \"testing\" ) type SendFunc struct { mock . Mock } func ( _m * SendFunc ) Execute ( data string ) ( int , error ) { ret := _m . Called ( data ) var r0 int if rf , ok := ret . Get ( 0 ).( func ( string ) int ); ok { r0 = rf ( data ) } else { r0 = ret . Get ( 0 ).( int ) } var r1 error if rf , ok := ret . Get ( 1 ).( func ( string ) error ); ok { r1 = rf ( data ) } else { r1 = ret . Error ( 1 ) } return r0 , r1 } // NewSendFunc creates a new instance of SendFunc. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations. func NewSendFunc ( t testing . TB ) * SendFunc { mock := & SendFunc {} mock . Mock . Test ( t ) t . Cleanup ( func () { mock . AssertExpectations ( t ) }) return mock }","title":"Function type case"},{"location":"examples/#return-value-provider-functions","text":"If your tests need access to the arguments to calculate the return values, set the return value to a function that takes the method's arguments as its own arguments and returns the return value. For example, given this interface: Go package test type Proxy interface { passthrough ( ctx context . Context , s string ) string } The argument can be passed through as the return value: Go import . \"github.com/stretchr/testify/mock\" proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) string { return s })","title":"Return Value Provider Functions"},{"location":"features/","text":"Features \u00b6 Replace Types \u00b6 v2.23.0 The replace-type parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages. The format of the parameter is: originalPackagePath.originalTypeName=newPackageName:newPackagePath.newTypeName For example: Bash mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz = baz:github.com/vektra/mockery/v2/baz.Baz This will replace any imported named \"github.com/vektra/mockery/v2/baz/internal/foo\" with baz \"github.com/vektra/mockery/v2/baz\" . The alias is defined with : before the package name. Also, the InternalBaz type that comes from this package will be renamed to baz.Baz . This next example fixes a common problem of type aliases that point to an internal package. cloud.google.com/go/pubsub.Message is a type alias defined like this: Go import ( ipubsub \"cloud.google.com/go/internal/pubsub\" ) type Message = ipubsub . Message The Go parser that mockery uses doesn't provide a way to detect this alias and sends the application the package and type name of the type in the internal package, which will not work. We can use replace-type with only the package part to replace any import of cloud.google.com/go/internal/pubsub to cloud.google.com/go/pubsub . We don't need to change the alias or type name in this case, because they are pubsub and Message in both cases. Bash mockery --replace-type cloud.google.com/go/internal/pubsub = cloud.google.com/go/pubsub Original source: Go import ( \"cloud.google.com/go/pubsub\" ) type Handler struct { HandleMessage ( m pubsub . Message ) error } Invalid mock generated without this parameter (points to an internal folder): Go import ( mock \"github.com/stretchr/testify/mock\" pubsub \"cloud.google.com/go/internal/pubsub\" ) func ( _m * Handler ) HandleMessage ( m pubsub . Message ) error { // ... return nil } Correct mock generated with this parameter. Go import ( mock \"github.com/stretchr/testify/mock\" pubsub \"cloud.google.com/go/pubsub\" ) func ( _m * Handler ) HandleMessage ( m pubsub . Message ) error { // ... return nil } packages configuration \u00b6 v2.21.0 \u00b7 Beta Feature Warning This feature is considered beta. The feature set has been solidifed, but we are asking users to beta-test for any bugs. Use at your own risk. This warning will be updated as this feature matures. Info See the Migration Docs on how to migrate to this new feature. Mockery has a configuration parameter called packages . In this config section, you define the packages and the intefaces you want mocks generated for. The packages can be any arbitrary package, either your own project or anything within the Go ecosystem. You may provide package-level or interface-level overrides to the default config you provide. Usage of the packages config section is desirable for mutiple reasons: Up to 5x increase in mock generation speed over the legacy method Granular control over interface generation, location, and file names Singular location for all config, instead of spread around by //go:generate statements Clean, easy to understand. Examples \u00b6 Here is an example configuration set: YAML with-expecter : True packages : github.com/vektra/mockery/v2/pkg : # (1)! interfaces : TypesPackage : RequesterVariadic : config : # (2)! with-expecter : False configs : - mockname : MockRequesterVariadicOneArgument unroll-variadic : False - mockname : MockRequesterVariadic io : config : all : True # (3)! interfaces : Writer : config : with-expecter : False # (4)! For this package, we provide no package-level config (which means we inherit the deafults at the top-level). Since our default of all: is False , mockery will only generate the interfaces we specify. We tell it which interface to generate by using the interfaces section and specifying an empty map, one for each interface. There might be cases where you want multiple mocks generated from the same interface. To do this, you can define a default config section for the interface, and further configs (plural) section, one for each mock. You must specify a mockname for the mocks in this section to differentiate them. This is telling mockery to generate all interfaces in the io package. We can provide interface-specifc overrides to the generation config. Templated variables \u00b6 Note Templated variables are only available when using the packages config feature. Included with this feature is the ability to use templated strings for various configuration options. This is useful to define where your mocks are placed and how to name them. You can view the template variables available in the Configuration section of the docs. Layouts \u00b6 Using different configuration parameters, we can deploy our mocks on-disk in various ways. These are some common layouts: layouts defaults adjacent to interface YAML filename : \"mock_{{.InterfaceName}}.go\" dir : \"mocks/{{.PackagePath}}\" mockname : \"Mock{{.InterfaceName}}\" outpkg : \"{{.PackageName}}\" If these variables aren't specified, the above values will be applied to the config options. This strategy places your mocks into a separate mocks/ directory. Interface Description name value InterfaceName MyDatabase PackagePath github.com/user/project/pkgName PackageName pkgName Output The mock will be generated at: Text Only mocks/github.com/user/project/pkgName/mock_MyDatabase.go The mock file will look like: Go package pkgName import mock \"github.com/stretchr/testify/mock\" type MockMyDatabase struct { mock . Mock } Warning Mockery does not protect against modifying original source code. Do not generate mocks using this config with uncommitted code changes. YAML filename : \"mock_{{.InterfaceName}}.go\" dir : \"{{.InterfaceDir}}\" mockname : \"Mock{{.InterfaceName}}\" outpkg : \"{{.PackageName}}\" inpackage : True Instead of the mocks being generated in a different folder, you may elect to generate the mocks alongside the original interface in your package. This may be the way most people define their configs, as it removes circular import issues that can happen with the default config. For example, the mock might be generated along side the original source file like this: Text Only ./path/to/pkg/db.go ./path/to/pkg/mock_MyDatabase.go Interface Description name value InterfaceName MyDatabase PackagePath github.com/user/project/path/to/pkg PackagePathRelative path/to/pkg PackageName pkgName SourceFile ./path/to/pkg/db.go Output Mock file will be generated at: Text Only ./path/to/pkg/mock_MyDatabase.go The mock file will look like: Go package pkgName import mock \"github.com/stretchr/testify/mock\" type MockMyDatabase struct { mock . Mock } Recursive package discovery \u00b6 v2.25.0 When recursive : true is set on a particular package: YAML packages : github.com/user/project : config : recursive : true with-expecter : true mockery will dynamically discover all sub-packages within the specified package. This is done by calling packages.Load on the specified package, which induces Go to download the package from the internet (or simply your local project). Mockery then recursively discovers all sub-directories from the root package that also contain .go files and injects the respective package path into the config map as if you had specified them manually. As an example, your in-memory config map may end up looking like this: YAML packages : github.com/user/project : config : recursive : true with-expecter : true github.com/user/project/subpkg1 : config : recursive : true with-expecter : true github.com/user/project/subpkg2 : config : recursive : true with-expecter : true You can use the showconfig command to see the config mockery injects. The output of showconfig theoretically could be copy-pasted into your yaml file as it is semantically equivalent. performance characteristics The performance when using recursive : true may be worse than manually specifying all packages statically in the yaml file. This is because of the fact that mockery has to recursively walk the filesystem path that contains the package in question. It may unnecessarily walk down unrelated paths (for example, a Python virtual environment that is in the same path as your package). For this reason, it is recommended not to use recursive : true if it can be avoided. Mock Constructors \u00b6 v2.11.0 All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits. Previously something like this would need to be done: Go factory := & mocks . Factory {} factory . Test ( t ) // so that mock does not panic when a method is unexpected defer factory . AssertExpectations ( t ) Instead, you may simply use the constructor: Go factory := mocks . NewFactory ( t ) The constructor sets up common functionalities automatically - The AssertExpectations method is registered to be called at the end of the tests via t.Cleanup() method. - The testing.TB interface is registered on the mock.Mock so that tests don't panic when a call on the mock is unexpected. Expecter Structs \u00b6 v2.10.0 \u00b7 with-expecter: True Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the with-expecter: True mockery configuration, you can enter into the expecter interface by simply calling .EXPECT() on your mock object. For example, given an interface such as Go type Requester interface { Get ( path string ) ( string , error ) } You can use the expecter interface as such: Go requesterMock := mocks . NewRequester ( t ) requesterMock . EXPECT (). Get ( \"some path\" ). Return ( \"result\" , nil ) A RunAndReturn method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call. Go requesterMock . EXPECT (). Get ( mock . Anything ). RunAndReturn ( func ( path string ) string { fmt . Println ( path , \"was called\" ) return \"result for \" + path }) Note Note that the types of the arguments on the EXPECT methods are interface{} , not the actual type of your interface. The reason for this is that you may want to pass mock.Any as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings. Return Value Providers \u00b6 v2.20.0 Return Value Providers can be used one of two ways. You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to Return , or you may pass multiple values to Return (one for each return parameter of the mocked function.) If you are using the second form, for each of the return values of the mocked function, Return needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of passthrough in the above example was instead (string, error) in the interface, Return would also need a second function argument to define the error value: Go type Proxy interface { passthrough ( ctx context . Context , s string ) ( string , error ) } First form: Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) ( string , error ) { return s , nil } ) Second form: Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) string { return s }, func ( ctx context . Context , s string ) error { return nil }, )","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#replace-types","text":"v2.23.0 The replace-type parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages. The format of the parameter is: originalPackagePath.originalTypeName=newPackageName:newPackagePath.newTypeName For example: Bash mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz = baz:github.com/vektra/mockery/v2/baz.Baz This will replace any imported named \"github.com/vektra/mockery/v2/baz/internal/foo\" with baz \"github.com/vektra/mockery/v2/baz\" . The alias is defined with : before the package name. Also, the InternalBaz type that comes from this package will be renamed to baz.Baz . This next example fixes a common problem of type aliases that point to an internal package. cloud.google.com/go/pubsub.Message is a type alias defined like this: Go import ( ipubsub \"cloud.google.com/go/internal/pubsub\" ) type Message = ipubsub . Message The Go parser that mockery uses doesn't provide a way to detect this alias and sends the application the package and type name of the type in the internal package, which will not work. We can use replace-type with only the package part to replace any import of cloud.google.com/go/internal/pubsub to cloud.google.com/go/pubsub . We don't need to change the alias or type name in this case, because they are pubsub and Message in both cases. Bash mockery --replace-type cloud.google.com/go/internal/pubsub = cloud.google.com/go/pubsub Original source: Go import ( \"cloud.google.com/go/pubsub\" ) type Handler struct { HandleMessage ( m pubsub . Message ) error } Invalid mock generated without this parameter (points to an internal folder): Go import ( mock \"github.com/stretchr/testify/mock\" pubsub \"cloud.google.com/go/internal/pubsub\" ) func ( _m * Handler ) HandleMessage ( m pubsub . Message ) error { // ... return nil } Correct mock generated with this parameter. Go import ( mock \"github.com/stretchr/testify/mock\" pubsub \"cloud.google.com/go/pubsub\" ) func ( _m * Handler ) HandleMessage ( m pubsub . Message ) error { // ... return nil }","title":"Replace Types"},{"location":"features/#packages-configuration","text":"v2.21.0 \u00b7 Beta Feature Warning This feature is considered beta. The feature set has been solidifed, but we are asking users to beta-test for any bugs. Use at your own risk. This warning will be updated as this feature matures. Info See the Migration Docs on how to migrate to this new feature. Mockery has a configuration parameter called packages . In this config section, you define the packages and the intefaces you want mocks generated for. The packages can be any arbitrary package, either your own project or anything within the Go ecosystem. You may provide package-level or interface-level overrides to the default config you provide. Usage of the packages config section is desirable for mutiple reasons: Up to 5x increase in mock generation speed over the legacy method Granular control over interface generation, location, and file names Singular location for all config, instead of spread around by //go:generate statements Clean, easy to understand.","title":"packages configuration"},{"location":"features/#examples","text":"Here is an example configuration set: YAML with-expecter : True packages : github.com/vektra/mockery/v2/pkg : # (1)! interfaces : TypesPackage : RequesterVariadic : config : # (2)! with-expecter : False configs : - mockname : MockRequesterVariadicOneArgument unroll-variadic : False - mockname : MockRequesterVariadic io : config : all : True # (3)! interfaces : Writer : config : with-expecter : False # (4)! For this package, we provide no package-level config (which means we inherit the deafults at the top-level). Since our default of all: is False , mockery will only generate the interfaces we specify. We tell it which interface to generate by using the interfaces section and specifying an empty map, one for each interface. There might be cases where you want multiple mocks generated from the same interface. To do this, you can define a default config section for the interface, and further configs (plural) section, one for each mock. You must specify a mockname for the mocks in this section to differentiate them. This is telling mockery to generate all interfaces in the io package. We can provide interface-specifc overrides to the generation config.","title":"Examples"},{"location":"features/#templated-variables","text":"Note Templated variables are only available when using the packages config feature. Included with this feature is the ability to use templated strings for various configuration options. This is useful to define where your mocks are placed and how to name them. You can view the template variables available in the Configuration section of the docs.","title":"Templated variables"},{"location":"features/#layouts","text":"Using different configuration parameters, we can deploy our mocks on-disk in various ways. These are some common layouts: layouts defaults adjacent to interface YAML filename : \"mock_{{.InterfaceName}}.go\" dir : \"mocks/{{.PackagePath}}\" mockname : \"Mock{{.InterfaceName}}\" outpkg : \"{{.PackageName}}\" If these variables aren't specified, the above values will be applied to the config options. This strategy places your mocks into a separate mocks/ directory. Interface Description name value InterfaceName MyDatabase PackagePath github.com/user/project/pkgName PackageName pkgName Output The mock will be generated at: Text Only mocks/github.com/user/project/pkgName/mock_MyDatabase.go The mock file will look like: Go package pkgName import mock \"github.com/stretchr/testify/mock\" type MockMyDatabase struct { mock . Mock } Warning Mockery does not protect against modifying original source code. Do not generate mocks using this config with uncommitted code changes. YAML filename : \"mock_{{.InterfaceName}}.go\" dir : \"{{.InterfaceDir}}\" mockname : \"Mock{{.InterfaceName}}\" outpkg : \"{{.PackageName}}\" inpackage : True Instead of the mocks being generated in a different folder, you may elect to generate the mocks alongside the original interface in your package. This may be the way most people define their configs, as it removes circular import issues that can happen with the default config. For example, the mock might be generated along side the original source file like this: Text Only ./path/to/pkg/db.go ./path/to/pkg/mock_MyDatabase.go Interface Description name value InterfaceName MyDatabase PackagePath github.com/user/project/path/to/pkg PackagePathRelative path/to/pkg PackageName pkgName SourceFile ./path/to/pkg/db.go Output Mock file will be generated at: Text Only ./path/to/pkg/mock_MyDatabase.go The mock file will look like: Go package pkgName import mock \"github.com/stretchr/testify/mock\" type MockMyDatabase struct { mock . Mock }","title":"Layouts"},{"location":"features/#recursive-package-discovery","text":"v2.25.0 When recursive : true is set on a particular package: YAML packages : github.com/user/project : config : recursive : true with-expecter : true mockery will dynamically discover all sub-packages within the specified package. This is done by calling packages.Load on the specified package, which induces Go to download the package from the internet (or simply your local project). Mockery then recursively discovers all sub-directories from the root package that also contain .go files and injects the respective package path into the config map as if you had specified them manually. As an example, your in-memory config map may end up looking like this: YAML packages : github.com/user/project : config : recursive : true with-expecter : true github.com/user/project/subpkg1 : config : recursive : true with-expecter : true github.com/user/project/subpkg2 : config : recursive : true with-expecter : true You can use the showconfig command to see the config mockery injects. The output of showconfig theoretically could be copy-pasted into your yaml file as it is semantically equivalent. performance characteristics The performance when using recursive : true may be worse than manually specifying all packages statically in the yaml file. This is because of the fact that mockery has to recursively walk the filesystem path that contains the package in question. It may unnecessarily walk down unrelated paths (for example, a Python virtual environment that is in the same path as your package). For this reason, it is recommended not to use recursive : true if it can be avoided.","title":"Recursive package discovery"},{"location":"features/#mock-constructors","text":"v2.11.0 All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits. Previously something like this would need to be done: Go factory := & mocks . Factory {} factory . Test ( t ) // so that mock does not panic when a method is unexpected defer factory . AssertExpectations ( t ) Instead, you may simply use the constructor: Go factory := mocks . NewFactory ( t ) The constructor sets up common functionalities automatically - The AssertExpectations method is registered to be called at the end of the tests via t.Cleanup() method. - The testing.TB interface is registered on the mock.Mock so that tests don't panic when a call on the mock is unexpected.","title":"Mock Constructors"},{"location":"features/#expecter-structs","text":"v2.10.0 \u00b7 with-expecter: True Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the with-expecter: True mockery configuration, you can enter into the expecter interface by simply calling .EXPECT() on your mock object. For example, given an interface such as Go type Requester interface { Get ( path string ) ( string , error ) } You can use the expecter interface as such: Go requesterMock := mocks . NewRequester ( t ) requesterMock . EXPECT (). Get ( \"some path\" ). Return ( \"result\" , nil ) A RunAndReturn method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call. Go requesterMock . EXPECT (). Get ( mock . Anything ). RunAndReturn ( func ( path string ) string { fmt . Println ( path , \"was called\" ) return \"result for \" + path }) Note Note that the types of the arguments on the EXPECT methods are interface{} , not the actual type of your interface. The reason for this is that you may want to pass mock.Any as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.","title":"Expecter Structs"},{"location":"features/#return-value-providers","text":"v2.20.0 Return Value Providers can be used one of two ways. You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to Return , or you may pass multiple values to Return (one for each return parameter of the mocked function.) If you are using the second form, for each of the return values of the mocked function, Return needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of passthrough in the above example was instead (string, error) in the interface, Return would also need a second function argument to define the error value: Go type Proxy interface { passthrough ( ctx context . Context , s string ) ( string , error ) } First form: Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) ( string , error ) { return s , nil } ) Second form: Go proxyMock := mocks . NewProxy ( t ) proxyMock . On ( \"passthrough\" , mock . AnythingOfType ( \"context.Context\" ), mock . AnythingOfType ( \"string\" )). Return ( func ( ctx context . Context , s string ) string { return s }, func ( ctx context . Context , s string ) error { return nil }, )","title":"Return Value Providers"},{"location":"installation/","text":"Getting Started \u00b6 Installation \u00b6 GitHub Release \u00b6 recommended Visit the releases page to download one of the pre-built binaries for your platform. go install \u00b6 Supported, but not recommended: see wiki page and related discussions . Text Only go install github.com/vektra/mockery/v2@v2.20.0 Warning Do not use @latest as this will pull from the latest, potentially untagged, commit on master. Docker \u00b6 Use the Docker image Text Only docker pull vektra/mockery Generate all the mocks for your project: Text Only docker run -v \"$PWD\":/src -w /src vektra/mockery --all Homebrew \u00b6 Install through brew Text Only brew install mockery brew upgrade mockery","title":"Installation"},{"location":"installation/#getting-started","text":"","title":"Getting Started"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#github-release","text":"recommended Visit the releases page to download one of the pre-built binaries for your platform.","title":"GitHub Release"},{"location":"installation/#go-install","text":"Supported, but not recommended: see wiki page and related discussions . Text Only go install github.com/vektra/mockery/v2@v2.20.0 Warning Do not use @latest as this will pull from the latest, potentially untagged, commit on master.","title":"go install"},{"location":"installation/#docker","text":"Use the Docker image Text Only docker pull vektra/mockery Generate all the mocks for your project: Text Only docker run -v \"$PWD\":/src -w /src vektra/mockery --all","title":"Docker"},{"location":"installation/#homebrew","text":"Install through brew Text Only brew install mockery brew upgrade mockery","title":"Homebrew"},{"location":"migrating_to_packages/","text":"The packages feature is a new configuration scheme that aims to simplify and improve a lot of legacy behavior. This will be the only way to generate mocks in v3. These docs outline general principals for migrating to the new scheme. Background \u00b6 mockery was built during the pre-module era of Golang. Much of its codebase and configuration syntax was designed around file-based operations. This model became highly inefficient once Golang migrated to module-based packages. The old configuration semantics also proved limiting -- many users introduced and requested feature additions to mockery to support esoteric use-cases. This proved to be a huge maintenance burden that existed solely because the configuration model could not flexibly describe all the situations users wanted. The packages semantics provides us a few highly desirable traits: Orders of magnitude performance increase, due to calling packages.Load once or twice for an entire project, versus once per file in the legacy semantics. Hierarchical configuration model that allows interface-specific config to be inherited from package-level config, which is inherited from defaults. Single configuration file that describes the entirety of mockery's behavior, instead of spread out by //go: generate statements. Extensive and flexible usage of a Golang string templating environment that allows users to dynamically specify parameter values. Configuration Changes \u00b6 The existence of the packages : map in your configuration acts as a feature flag that enables the feature. The configuration parameters used in packages should be considered to have no relation to their meanings in the legacy scheme. It is recommended to wipe out all previous configuration and command-line parameters previously used. The configuration docs show the parameters that are available for use in the packages scheme. You should only use the parameters shown in this section. Mockery will not prevent you from using the legacy parameter set, but doing so will result in undefined behavior. All of the parameters in the config section can be specified at the top level of the config file, which serves as the default values. The packages config section defines package-specific config. See some exampes here . //go: generate directives \u00b6 Previously, the recommended way of generating mocks was to call mockery once per interface using //go: generate . Generating interface-specific mocks this way is no longer supported. You may still use //go: generate to call mockery, however it will generate all interfaces defined in your config file. There currently exists no semantics to specify the generation of specific interfaces from the command line (not because we reject the idea, but because it was not seen as a requirement for the initial iteration of packages ). Behavior Changes \u00b6 The legacy behavior iterated over every .go file in your project, called packages.Load to parse the syntax tree, and generated mocks for every interface found in the file. The new behavior instead simply grabs the list of packages to load from the config file, or in the case of recursive : True , walks the filesystem tree to discover the packages that exist (without actually parsing the files). Using this list, it calls packages.Load once with the list of packages that were discovered. Filesystem Tree Layouts \u00b6 The legacy config provided the keeptree parameter which, if keeptree : True , would place the mocks in the same package as your interfaces. Otherwise, it would place it in a separate directory. These two layouts are supported in the packages scheme. See the relevant docs here .","title":"Migrating to Packages"},{"location":"migrating_to_packages/#background","text":"mockery was built during the pre-module era of Golang. Much of its codebase and configuration syntax was designed around file-based operations. This model became highly inefficient once Golang migrated to module-based packages. The old configuration semantics also proved limiting -- many users introduced and requested feature additions to mockery to support esoteric use-cases. This proved to be a huge maintenance burden that existed solely because the configuration model could not flexibly describe all the situations users wanted. The packages semantics provides us a few highly desirable traits: Orders of magnitude performance increase, due to calling packages.Load once or twice for an entire project, versus once per file in the legacy semantics. Hierarchical configuration model that allows interface-specific config to be inherited from package-level config, which is inherited from defaults. Single configuration file that describes the entirety of mockery's behavior, instead of spread out by //go: generate statements. Extensive and flexible usage of a Golang string templating environment that allows users to dynamically specify parameter values.","title":"Background"},{"location":"migrating_to_packages/#configuration-changes","text":"The existence of the packages : map in your configuration acts as a feature flag that enables the feature. The configuration parameters used in packages should be considered to have no relation to their meanings in the legacy scheme. It is recommended to wipe out all previous configuration and command-line parameters previously used. The configuration docs show the parameters that are available for use in the packages scheme. You should only use the parameters shown in this section. Mockery will not prevent you from using the legacy parameter set, but doing so will result in undefined behavior. All of the parameters in the config section can be specified at the top level of the config file, which serves as the default values. The packages config section defines package-specific config. See some exampes here .","title":"Configuration Changes"},{"location":"migrating_to_packages/#go-generate-directives","text":"Previously, the recommended way of generating mocks was to call mockery once per interface using //go: generate . Generating interface-specific mocks this way is no longer supported. You may still use //go: generate to call mockery, however it will generate all interfaces defined in your config file. There currently exists no semantics to specify the generation of specific interfaces from the command line (not because we reject the idea, but because it was not seen as a requirement for the initial iteration of packages ).","title":"//go: generate directives"},{"location":"migrating_to_packages/#behavior-changes","text":"The legacy behavior iterated over every .go file in your project, called packages.Load to parse the syntax tree, and generated mocks for every interface found in the file. The new behavior instead simply grabs the list of packages to load from the config file, or in the case of recursive : True , walks the filesystem tree to discover the packages that exist (without actually parsing the files). Using this list, it calls packages.Load once with the list of packages that were discovered.","title":"Behavior Changes"},{"location":"migrating_to_packages/#filesystem-tree-layouts","text":"The legacy config provided the keeptree parameter which, if keeptree : True , would place the mocks in the same package as your interfaces. Otherwise, it would place it in a separate directory. These two layouts are supported in the packages scheme. See the relevant docs here .","title":"Filesystem Tree Layouts"},{"location":"notes/","text":"Frequently Asked Questions \u00b6 error: no go files found in root search path \u00b6 When using the packages feature, recursive: true and you have specified a package that contains no *.go files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata. The solution is to create a .go file in the package's path and add a package [name] directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata. Discussion internal error: package without types was imported \u00b6 https://github.com/vektra/mockery/issues/475 This issue indicates an incompatability that exists with one of your cached Golang packages. The solution is to run go clean -modcache . This issue also happens when compiling from source, such as with go install . You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the .tar.gz binaries, or through brew install . Multiple Expectations With Identical Arguments \u00b6 There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example we might want to test this behavior: Go // Return \"foo\" on the first call getter := NewGetter () assert ( t , \"foo\" , getter . Get ( \"key\" )) // Return \"bar\" on the second call assert ( t , \"bar\" , getter . Get ( \"key\" )) This can be done by using the .Once() method on the mock call expectation: Go mockGetter := NewMockGetter ( t ) mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"foo\" ). Once () mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"bar\" ). Once () Or you can identify an arbitrary number of times each value should be returned: Go mockGetter := NewMockGetter ( t ) mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"foo\" ). Times ( 4 ) mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"bar\" ). Times ( 2 ) Note that with proper Golang support in your IDE, all of the available methods are self-documented in auto-completion help contexts. Variadic Arguments \u00b6 Consider if we have a function func Bar ( message ... string ) error . A typical assertion might look like this: Go func TestFoo ( t * testing . T ) { m := NewMockFoo ( t ) m . On ( \"Bar\" , \"hello\" , \"world\" ). Return ( nil ) We might also want to make an assertion that says \"any number of variadic arguments\": Go m . On ( \"Bar\" , mock . Anything ). Return ( nil ) However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions: Any number of variadic arguments of any value A single variadic argument of any value This is fixed in #359 where you can provide unroll-variadic: False to get back to the old behavior. Thus, if you want to assert (1), you can then do: Go m . On ( \"Bar\" , mock . Anything ). Return ( nil ) If you want to assert (2), you must set unroll-variadic: True . Then this assertion's intention will be modified to mean the second case: Go m . On ( \"Bar\" , mock . Anything ). Return ( nil ) An upstream patch to testify is currently underway to allow passing mock.Anything directly to the variadic slice: https://github.com/stretchr/testify/pull/1348 If this is merged, it would become possible to describe the above two cases respectively: Go // case 1 m . On ( \"Bar\" , mock . Anything ). Return ( nil ) // case 2 m . On ( \"Bar\" , [] interface {}{ mock . Anything }). Return ( nil ) References: https://github.com/vektra/mockery/pull/359 https://github.com/vektra/mockery/pull/123 https://github.com/vektra/mockery/pull/550 https://github.com/vektra/mockery/issues/541 Semantic Versioning \u00b6 The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following: CLI arguments. Parsing of Golang code. New features in the Golang language will be supported in a backwards-compatible manner, except during major version bumps. Behavior of mock objects. Mock objects can be considered to be part of the public API. Behavior of mockery given a set of arguments. What the version does not track: The interfaces, objects, methods etc. in the vektra/mockery package. Compatibility of go get -ing mockery with new or old versions of Golang. Mocking interfaces in main \u00b6 When your interfaces are in the main package, you should supply the --inpackage flag. This will generate mocks in the same package as the target code, avoiding import issues.","title":"FAQ"},{"location":"notes/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"notes/#error-no-go-files-found-in-root-search-path","text":"When using the packages feature, recursive: true and you have specified a package that contains no *.go files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata. The solution is to create a .go file in the package's path and add a package [name] directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata. Discussion","title":"error: no go files found in root search path"},{"location":"notes/#internal-error-package-without-types-was-imported","text":"https://github.com/vektra/mockery/issues/475 This issue indicates an incompatability that exists with one of your cached Golang packages. The solution is to run go clean -modcache . This issue also happens when compiling from source, such as with go install . You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the .tar.gz binaries, or through brew install .","title":"internal error: package without types was imported"},{"location":"notes/#multiple-expectations-with-identical-arguments","text":"There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example we might want to test this behavior: Go // Return \"foo\" on the first call getter := NewGetter () assert ( t , \"foo\" , getter . Get ( \"key\" )) // Return \"bar\" on the second call assert ( t , \"bar\" , getter . Get ( \"key\" )) This can be done by using the .Once() method on the mock call expectation: Go mockGetter := NewMockGetter ( t ) mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"foo\" ). Once () mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"bar\" ). Once () Or you can identify an arbitrary number of times each value should be returned: Go mockGetter := NewMockGetter ( t ) mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"foo\" ). Times ( 4 ) mockGetter . EXPECT (). Get ( mock . anything ). Return ( \"bar\" ). Times ( 2 ) Note that with proper Golang support in your IDE, all of the available methods are self-documented in auto-completion help contexts.","title":"Multiple Expectations With Identical Arguments"},{"location":"notes/#variadic-arguments","text":"Consider if we have a function func Bar ( message ... string ) error . A typical assertion might look like this: Go func TestFoo ( t * testing . T ) { m := NewMockFoo ( t ) m . On ( \"Bar\" , \"hello\" , \"world\" ). Return ( nil ) We might also want to make an assertion that says \"any number of variadic arguments\": Go m . On ( \"Bar\" , mock . Anything ). Return ( nil ) However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions: Any number of variadic arguments of any value A single variadic argument of any value This is fixed in #359 where you can provide unroll-variadic: False to get back to the old behavior. Thus, if you want to assert (1), you can then do: Go m . On ( \"Bar\" , mock . Anything ). Return ( nil ) If you want to assert (2), you must set unroll-variadic: True . Then this assertion's intention will be modified to mean the second case: Go m . On ( \"Bar\" , mock . Anything ). Return ( nil ) An upstream patch to testify is currently underway to allow passing mock.Anything directly to the variadic slice: https://github.com/stretchr/testify/pull/1348 If this is merged, it would become possible to describe the above two cases respectively: Go // case 1 m . On ( \"Bar\" , mock . Anything ). Return ( nil ) // case 2 m . On ( \"Bar\" , [] interface {}{ mock . Anything }). Return ( nil ) References: https://github.com/vektra/mockery/pull/359 https://github.com/vektra/mockery/pull/123 https://github.com/vektra/mockery/pull/550 https://github.com/vektra/mockery/issues/541","title":"Variadic Arguments"},{"location":"notes/#semantic-versioning","text":"The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following: CLI arguments. Parsing of Golang code. New features in the Golang language will be supported in a backwards-compatible manner, except during major version bumps. Behavior of mock objects. Mock objects can be considered to be part of the public API. Behavior of mockery given a set of arguments. What the version does not track: The interfaces, objects, methods etc. in the vektra/mockery package. Compatibility of go get -ing mockery with new or old versions of Golang.","title":"Semantic Versioning"},{"location":"notes/#mocking-interfaces-in-main","text":"When your interfaces are in the main package, you should supply the --inpackage flag. This will generate mocks in the same package as the target code, avoiding import issues.","title":"Mocking interfaces in main"},{"location":"running/","text":"Running \u00b6 Using go generate recommended \u00b6 go generate is often preferred as it give you more targeted generation of specific interfaces. Use generate as a directive above the interface you want to generate a mock for. Go package example_project //go:generate mockery --name Root type Root interface { Foobar ( s string ) error } Then simply: Bash $ go generate 09 Feb 23 22 :55 CST INF Starting mockery dry-run = false version = v2.18.0 09 Feb 23 22 :55 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run = false version = v2.18.0 09 Feb 23 22 :55 CST INF Walking dry-run = false version = v2.18.0 09 Feb 23 22 :55 CST INF Generating mock dry-run = false interface = Root qualified-name = github.com/vektra/mockery/v2/pkg/fixtures/example_project version = v2.18.0 For all interfaces in project \u00b6 If you provide all: True , you can generate mocks for the entire project. This is not recommended for larger projects as it can take a large amount of time parsing packages to generate mocks that you might never use. Bash $ mockery 09 Feb 23 22 :47 CST INF Starting mockery dry-run = false version = v2.18.0 09 Feb 23 22 :47 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run = false version = v2.18.0 09 Feb 23 22 :47 CST INF Walking dry-run = false version = v2.18.0 09 Feb 23 22 :47 CST INF Generating mock dry-run = false interface = A qualified-name = github.com/vektra/mockery/v2/pkg/fixtures version = v2.18.0 Note Note that in some cases, using //go:generate may turn out to be slower than running for entire packages. go:generate calls mockery once for each generate directive, which means that mockery may need to parse the package multiple times, which is wasteful. Good judgement is recommended when determining the best option for your own project. Note For mockery to correctly generate mocks, the command has to be run on a module (i.e. your project has to have a go.mod file)","title":"Running"},{"location":"running/#running","text":"","title":"Running"},{"location":"running/#using-go-generate-recommended","text":"go generate is often preferred as it give you more targeted generation of specific interfaces. Use generate as a directive above the interface you want to generate a mock for. Go package example_project //go:generate mockery --name Root type Root interface { Foobar ( s string ) error } Then simply: Bash $ go generate 09 Feb 23 22 :55 CST INF Starting mockery dry-run = false version = v2.18.0 09 Feb 23 22 :55 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run = false version = v2.18.0 09 Feb 23 22 :55 CST INF Walking dry-run = false version = v2.18.0 09 Feb 23 22 :55 CST INF Generating mock dry-run = false interface = Root qualified-name = github.com/vektra/mockery/v2/pkg/fixtures/example_project version = v2.18.0","title":"Using go generate recommended"},{"location":"running/#for-all-interfaces-in-project","text":"If you provide all: True , you can generate mocks for the entire project. This is not recommended for larger projects as it can take a large amount of time parsing packages to generate mocks that you might never use. Bash $ mockery 09 Feb 23 22 :47 CST INF Starting mockery dry-run = false version = v2.18.0 09 Feb 23 22 :47 CST INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run = false version = v2.18.0 09 Feb 23 22 :47 CST INF Walking dry-run = false version = v2.18.0 09 Feb 23 22 :47 CST INF Generating mock dry-run = false interface = A qualified-name = github.com/vektra/mockery/v2/pkg/fixtures version = v2.18.0 Note Note that in some cases, using //go:generate may turn out to be slower than running for entire packages. go:generate calls mockery once for each generate directive, which means that mockery may need to parse the package multiple times, which is wasteful. Good judgement is recommended when determining the best option for your own project. Note For mockery to correctly generate mocks, the command has to be run on a module (i.e. your project has to have a go.mod file)","title":"For all interfaces in project"},{"location":"ve/lib/python3.6/site-packages/Markdown-3.3.7.dist-info/LICENSE/","text":"Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Python Markdown Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE PYTHON MARKDOWN PROJECT ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANY CONTRIBUTORS TO THE PYTHON MARKDOWN PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"ve/lib/python3.6/site-packages/mkdocs_glightbox/glightbox/LICENSE/","text":"MIT License Copyright (c) 2018 Biati Digital https://www.biati.digital Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"ve/lib/python3.6/site-packages/mkdocs_material_extensions-1.0.3.dist-info/LICENSE/","text":"MIT License Copyright (c) 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/","text":"License \u00b6 PyMdown Extensions \u00b6 The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SuperFences \u00b6 superfences.py is derived from Python Markdown's fenced_code extension. Text Only Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See <https://python-markdown.github.io/extensions/fenced_code_blocks/> for documentation. Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php) Highlight \u00b6 highlight.py is derived from Python Markdown's CodeHilite extension. Text Only CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See <https://python-markdown.github.io/extensions/code_hilite/> for documentation. Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php) Gemoji Index \u00b6 gemoji_db.py is generated from Gemoji's source code: @github/gemoji. Text Only Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. EmojiOne Index \u00b6 emoji1_db.py is generated from EmojiOne's source code: @Ranks/emojione Text Only EmojiOne Non-Artwork Applies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"License"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#license","text":"","title":"License"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#pymdown-extensions","text":"The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"PyMdown Extensions"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#superfences","text":"superfences.py is derived from Python Markdown's fenced_code extension. Text Only Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See <https://python-markdown.github.io/extensions/fenced_code_blocks/> for documentation. Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php)","title":"SuperFences"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#highlight","text":"highlight.py is derived from Python Markdown's CodeHilite extension. Text Only CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See <https://python-markdown.github.io/extensions/code_hilite/> for documentation. Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php)","title":"Highlight"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#gemoji-index","text":"gemoji_db.py is generated from Gemoji's source code: @github/gemoji. Text Only Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Gemoji Index"},{"location":"ve/lib/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#emojione-index","text":"emoji1_db.py is generated from EmojiOne's source code: @Ranks/emojione Text Only EmojiOne Non-Artwork Applies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"EmojiOne Index"},{"location":"ve/lib64/python3.6/site-packages/Markdown-3.3.7.dist-info/LICENSE/","text":"Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Python Markdown Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE PYTHON MARKDOWN PROJECT ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANY CONTRIBUTORS TO THE PYTHON MARKDOWN PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"ve/lib64/python3.6/site-packages/mkdocs_glightbox/glightbox/LICENSE/","text":"MIT License Copyright (c) 2018 Biati Digital https://www.biati.digital Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"ve/lib64/python3.6/site-packages/mkdocs_material_extensions-1.0.3.dist-info/LICENSE/","text":"MIT License Copyright (c) 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/","text":"License \u00b6 PyMdown Extensions \u00b6 The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. SuperFences \u00b6 superfences.py is derived from Python Markdown's fenced_code extension. Text Only Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See <https://python-markdown.github.io/extensions/fenced_code_blocks/> for documentation. Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php) Highlight \u00b6 highlight.py is derived from Python Markdown's CodeHilite extension. Text Only CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See <https://python-markdown.github.io/extensions/code_hilite/> for documentation. Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php) Gemoji Index \u00b6 gemoji_db.py is generated from Gemoji's source code: @github/gemoji. Text Only Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. EmojiOne Index \u00b6 emoji1_db.py is generated from EmojiOne's source code: @Ranks/emojione Text Only EmojiOne Non-Artwork Applies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"License"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#license","text":"","title":"License"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#pymdown-extensions","text":"The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"PyMdown Extensions"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#superfences","text":"superfences.py is derived from Python Markdown's fenced_code extension. Text Only Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See <https://python-markdown.github.io/extensions/fenced_code_blocks/> for documentation. Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php)","title":"SuperFences"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#highlight","text":"highlight.py is derived from Python Markdown's CodeHilite extension. Text Only CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See <https://python-markdown.github.io/extensions/code_hilite/> for documentation. Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/). All changes Copyright 2008-2014 The Python Markdown Project License: [BSD](http://www.opensource.org/licenses/bsd-license.php)","title":"Highlight"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#gemoji-index","text":"gemoji_db.py is generated from Gemoji's source code: @github/gemoji. Text Only Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Gemoji Index"},{"location":"ve/lib64/python3.6/site-packages/pymdown_extensions-9.1.dist-info/LICENSE/#emojione-index","text":"emoji1_db.py is generated from EmojiOne's source code: @Ranks/emojione Text Only EmojiOne Non-Artwork Applies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"EmojiOne Index"}]}